#!/usr/bin/python2.7

import sys
from math import *
from collections import defaultdict

# only look at the upper triangluar results.
upper_only = True

def logsumexp(xs):
    mm = max(xs)
    return mm + log(sum((exp(xx-mm) for xx in xs)))

def load(fname):
    truth = defaultdict(dict)
    lprob = defaultdict(dict)
    with open(fname) as pred:
        for line in pred.readlines():
            fields = [field.strip() for field in line.split(',')]
            if len(fields) == 6:
                time_taken, src, dst, correct, lp_false, lp_true = fields
            else:
                src, dst, correct, lp_false, lp_true = fields
                time_taken = 0.0
            if upper_only and src < dst:
                continue
            time_taken = float(time_taken)
            truth[time_taken][src, dst] = correct == "true"
            lprob[time_taken][src, dst] = { False: float(lp_false), True: float(lp_true) }
            acc = 1e-8
            #pred = lprob[time_taken][src,dst][True] > lprob[time_taken][src,dst][False]
            #pred = truth[time_taken][src,dst]
            #lprob[time_taken][src,dst][pred] = log(1.0 - acc)
            #lprob[time_taken][src,dst][not pred] = log(acc)
            #lprob[time_taken][src,dst][False] = log(0.5 + acc)
            #lprob[time_taken][src,dst][True] = log(0.5 - acc)
    return truth, lprob

def merge_preds(truthfiles, lprobfiles):
    # increment time offset as we process each truth file.
    time_offset = 0.0
    # truths, lprobs results we've seen so far
    acc_truths = []
    acc_lprobs = []
    # process each file in turn
    truths = {}
    lprobs = {}
    for ii, truthfile in enumerate(truthfiles):
        for time_taken in truthfile:
            acc_truths.append(truthfile[time_taken])
            acc_lprobs.append(lprobfiles[ii][time_taken])
            truth, lprob = blend_preds(acc_truths, acc_lprobs)
            time_offset += time_taken
            truths[time_offset] = truth
            lprobs[time_offset] = lprob

    check_truths(truths.values())
    return truths, lprobs

def blend_preds(truths, lprobs):
    check_truths(truths)
    nn = 0.0
    acc_lprob = defaultdict(lambda: defaultdict(int))
    for lprob in lprobs:
        nn += 1.0
        for src, dst in lprob.keys():
            acc_lprob[src, dst][False] += lprob[src, dst][False]
            acc_lprob[src, dst][True] += lprob[src, dst][True]

    for src, dst in acc_lprob.keys():
        acc_lprob[src, dst][False] /= nn
        acc_lprob[src, dst][True] /= nn
    return truths[0], acc_lprob

def check_truths(truths):
    truth0 = truths[0]
    for truth in truths[1:]:
        if truth != truth0:
            raise 'truth mismatch'

def check_sum(lprob):
    for kk in lprob:
        zz = logsumexp(lprob[kk].values())
        if zz > 1e-5:
            print kk, zz

def mean(xs):
    return sum(xs)/float(len(xs))

def var(xs):
    mm = mean(xs)
    return sum((x*x for x in xs))/float(len(xs)) - mm*mm

def std(xs):
    return sqrt(max(0, var(xs)))

def std_err(xs):
    nn = len(xs)
    return std(xs)/sqrt(nn)

def avg_log_prob(truth, lprob):
    lp = []
    for src, dst in truth:
        lp.append(lprob[src, dst][truth[src, dst]])
    return mean(lp), std_err(lp)

def loss01(truth, lprob):
    total = 0.0
    wrong = 0.0
    for src, dst in truth:
        if upper_only and src < dst:
            continue
        total += 1.0
        call = max(lprob[src, dst].keys(), key=lambda kk: lprob[src,dst][kk])
        if call != truth[src, dst]:
            wrong += 1.0
    return wrong/total

def rmse(truth, lprob):
    se = []
    for src, dst in truth:
        if upper_only and src < dst:
            continue
        correct = 0.0
        if truth[src, dst]:
            correct = 1.0
        p = exp(lprob[src,dst][True])
        se.append(correct - 2*correct*p + p)
    return sqrt(mean(se))

def auc(truth, lprob):
    # number of links and non-links in truth
    nl = float(sum(truth.values()))
    nn = float(len(truth) - nl)
    assert(nl + nn == len(truth))
    # ri is the rank of the ith positive example
    So = 0.0
    sorted_k = sorted(truth.keys(), key=lambda kk: lprob[kk][True])
    for ii, kk in enumerate(sorted_k):
        if truth[kk]:
            So += ii+1

    return (So - (nl*(nl+1))/2)/(nl*nn)

def main():
    truthfiles = []
    lprobfiles = []
    for fname in sys.argv[1:]:
        truth, lprob = load(fname)
        truthfiles.append(truth)
        lprobfiles.append(lprob)

    check_truths([truthfile[tt] for truthfile in truthfiles for tt in truthfile])
    truths, lprobs = merge_preds(truthfiles, lprobfiles)

    print 'time','lpred_mean','lpred_se','loss01','rmse','auc'
    for time_taken in truths.keys():
        truth = truths[time_taken]
        lprob = lprobs[time_taken]
        check_sum(lprob)
        lpred_mean, lpred_se = avg_log_prob(truth, lprob)
        print time_taken, lpred_mean, lpred_se,
        print loss01(truth, lprob), rmse(truth, lprob),
        print auc(truth, lprob)

if __name__ == '__main__':
    main()
